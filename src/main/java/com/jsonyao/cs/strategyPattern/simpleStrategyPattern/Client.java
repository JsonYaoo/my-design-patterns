package com.jsonyao.cs.strategyPattern.simpleStrategyPattern;

/**
 * 策略模式
 * A. 定义
 *      a. 定义一组算法, 将每一个算法封装起来, 从而使它们可以相互切换
 * B. 特点
 *      a. 一组算法就是不同的策略
 *      b. 之所以可以相互切换, 是因为实现了相同的接口或者继承了相同的抽象类
 * C. 组成
 *      a. 策略封装角色: 上层访问策略入口, 持有抽象策略的引用(聚合关系)
 *      b. 抽象策略角色: 提供接口或抽象类, 定义策略组必须拥有的方法和属性
 *      c. 具体策略角色: 实现抽象策略, 定义具体的算法逻辑
 * D. 策略模式的优点
 *      a. 策略模式提供了管理相关算法族的方法, 其等级结构定义了一个算法或者行为族, 恰当使用继承和接口可以把公共的代码进行抽取, 避免代码重复
 *      b. 使用策略模式可以避免使用多重条件if-else语句, 而if-else语句不易维护, 因为把采取哪一种算法或行为的逻辑, 与算法或行为本身的逻辑混合在了一起,
 *         统统列在一个语句里面, 比使用继承的办法还要原始和落后
 * E. 策略模式的缺点
 *      a. 客户端必须知道所有的策略类, 并自行决定使用哪一个策略类. 这就意味着客户端必须理解这些算法的区别, 以便适时选择适当的算法类, 因此,
 *         策略模式只适用于客户端知道算法或者行为的情况
 *      b. 由于策略模式把每个具体的策略实现都单独封装成类, 如果备选的策略很多, 那么对象的数目就会很可观
 */
public class Client {

    public static void main(String[] args) {
        Context context = new Context(new StrategyB());
        context.useStrateyAlgorithmLogic();
    }
}
